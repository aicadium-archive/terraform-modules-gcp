image: ${image}
imageTag: ${image_tag}

serviceType: ${service_type}
loadBalancerIP: "${external_static_ip}"
loadBalancerSourceRanges:  ${jsonencode(external_lb_cidr)}
# whiteListSourceRange: []
externalTrafficPolicy: ${external_traffic_policy}
replicas: ${replicas}

# startupArguments:
#   - "--ping"
#   - "--ping.entrypoint=http"

podDisruptionBudget: {}
  # maxUnavailable: 1
  # minAvailable: 2

# priorityClassName: ""

# rootCAs: []

cpuRequest: ${cpu_request}
memoryRequest: ${memory_request}
cpuLimit: ${cpu_limit}
memoryLimit: ${memory_limit}

debug:
  enabled: false

deploymentStrategy: {}
  # rollingUpdate:
  #   maxSurge: 1
  #   maxUnavailable: 0
  # type: RollingUpdate

nodeSelector: ${jsonencode(node_selector)}

affinity: ${jsonencode(affinity)}

tolerations: []
# - key: "key"
#   operator: "Equal|Exists"
#   value: "value"
#   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
## Kubernetes ingress filters
# kubernetes:
  # endpoint:
  # namespaces:
  # - default
  # labelSelector:
  # ingressClass:
  # ingressEndpoint:
  #   hostname: "localhost"
  #   ip: "127.0.0.1"
  #   publishedService: "namespace/servicename"
  #   useDefaultPublishedService: false
proxyProtocol:
  enabled: false
  # trustedIPs is required when enabled
  trustedIPs: []
  # - 10.0.0.0/8
forwardedHeaders:
  enabled: false
  # trustedIPs is required when enabled
  trustedIPs: []
  # - 10.0.0.0/8
ssl:
  enabled: false
  enforced: false
  permanentRedirect: false
  upstream: false
  insecureSkipVerify: false
  generateTLS: false

kvprovider:
  ## If you want to run Traefik in HA mode, you will need to setup a KV Provider. Therefore you can choose one of
  ## * etcd
  ## * consul
  ## * boltdb
  ## * zookeeper
  ##
  ## ref: https://docs.traefik.io/user-guide/cluster/

  ## storeAcme has to be enabled to support HA Support using acme, but at least one kvprovider is needed
  storeAcme: false
  importAcme: false

  # consul:
    # endpoint: consul-service:8500
    # watch: true
    # prefix: traefik

    ## Override default configuration template.
    ## For advanced users :)
    ##
    ## Optional
    # filename: consul.tmpl
    # username: foo
    # password: bar
    # tls:
    #   ca: "/etc/ssl/ca.crt"
    #   cert: "/etc/ssl/consul.crt"
    #   key: "/etc/ssl/consul.key"
    #   insecureSkipVerify: true

    ## only relevant for etcd


acme:
  enabled: false
  email: admin@example.com
  onHostRule: true
  staging: true
  logging: false
  # Configure a Let's Encrypt certificate to be managed by default.
  # This is the only way to request wildcard certificates (works only with dns challenge).
  domains:
    enabled: false
    # List of sets of main and (optional) SANs to generate for
    # for wildcard certificates see https://docs.traefik.io/configuration/acme/#wildcard-domains
    domainsList:
      # - main: "*.example.com"
      # - sans:
      #   - "example.com"
      # - main: "*.example2.com"
      # - sans:
      #   - "test1.example2.com"
      #   - "test2.example2.com"
  ## ACME challenge type: "tls-sni-01", "tls-alpn-01", "http-01" or "dns-01"
  ## Note the chart's default of tls-sni-01 has been DEPRECATED and (except in
  ## certain circumstances) DISABLED by Let's Encrypt. It remains as a default
  ## value in this chart to preserve legacy behavior and avoid a breaking
  ## change. Users of this chart should strongly consider making the switch to
  ## the recommended "tls-alpn-01" (avaialbe since v1.7), dns-01 or http-01
  ## (available since v1.5) challenge.
  challengeType: dns-01
  ## Configure dnsProvider to perform domain verification using dns challenge
  ## Applicable only if using the dns-01 challenge type
  delayBeforeCheck: 0
  dnsProvider:
    name: gcloud
    gcloud:
      GCE_PROJECT: ""
      GCE_SERVICE_ACCOUNT_FILE: ""
  ## Save ACME certs to a persistent volume.
  ## WARNING: If you do not do this and you did not have configured
  ## a kvprovider, you will re-request certs every time a pod (re-)starts
  ## and you WILL be rate limited!
  persistence:
    enabled: true
    annotations: {}
    ## acme data Persistent Volume Storage Class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    # storageClass: "-"
    accessMode: ReadWriteOnce
    size: 1Gi
    ## A manually managed Persistent Volume Claim
    ## Requires persistence.enabled: true
    ## If defined, PVC must be created manually before volume will be bound
    ##
    # existingClaim:
dashboard:
  enabled: false
  domain: traefik.example.com
  # serviceType: ClusterIP
  service: {}
    # annotations:
    #   key: value
  ingress: {}
    # annotations:
    #   key: value
    # labels:
    #   key: value
    # tls:
      # - hosts:
      #   - traefik.example.com
      #   secretName: traefik-default-cert
  auth: {}
    # basic:
    #   username: password
  statistics: {}
    ## Number of recent errors to show in the ‘Health’ tab
    # recentErrors:
service:
  annotations: ${jsonencode(service_annotations)}
  labels: ${jsonencode(service_labels)}

  ## Further config for service of type NodePort
  ## Default config with empty string "" will assign a dynamic
  ## nodePort to http and https ports
  nodePorts:
    http: "80"
    https: "443"

gzip:
  enabled: true
traefikLogFormat: json
accessLogs:
  enabled: false
  ## Path to the access logs file. If not provided, Traefik defaults it to stdout.
  # filePath: ""
  format: json  # choices are: common, json
  ## for JSON logging, finer-grained control over what is logged. Fields can be
  ## retained or dropped, and request headers can be retained, dropped or redacted
  fields:
    # choices are keep, drop
    defaultMode: keep
    names: {}
      # ClientUsername: drop
    headers:
      # choices are keep, drop, redact
      defaultMode: keep
      names: {}
        # Authorization: redact
rbac:
  enabled: ${rbac_enabled}
## Enable the /metrics endpoint, for now only supports prometheus
## set to true to enable metric collection by prometheus
metrics:
  prometheus:
    enabled: false
    ## If true, prevents exposing port 8080 on the main Traefik service, reserving
    ## it to the dashboard service only
    restrictAccess: false
    # buckets: [0.1,0.3,1.2,5]

deployment:
  podLabels: ${jsonencode(pod_labels)}
  podAnnotations: ${jsonencode(pod_annotations)}
  hostPort:
    httpEnabled: false
    httpsEnabled: false
    dashboardEnabled: false
sendAnonymousUsage: false
tracing:
  enabled: false
  serviceName: traefik
  # backend: choices are jaeger, zipkin, datadog
  # jaeger:
  #   localAgentHostPort: "127.0.0.1:6831"
  #   samplingServerURL: http://localhost:5778/sampling
  #   samplingType: const
  #   samplingParam: 1.0
  # zipkin:
  #   httpEndpoint: http://localhost:9411/api/v1/spans
  #   debug: false
  #   sameSpan: false
  #   id128bit: true
  # datadog:
  #   localAgentHostPort: "127.0.0.1:8126"
  #   debug: false
  #   globalTag: ""
